%This script reads the bin and meta files generated by spikeGLX and
% extracts behavioral timestamps (reachStart, reachStop, reward delivery, licks). 
% from Junchol 9.17.17
% Best to run this script on the IMEC machine!

clear all; clear functions; clc

%NOTE Beth's relevent Whisper channels:
% - 193 = trial starts/sol - only the solenoid blip is showing up
% - 195 = wheel definitely works!
% - 225 = lick (should be working)
% - 227 = laser (not using)

%% Raw voltage traces from bin and meta files
addpath(genpath('C:\Users\labadmin\Documents\MATLAB'))
addpath(genpath('C:\Users\labadmin\Documents\MATLAB\SpikeGLX-master 2\MATLAB-SDK')) % the folder with spikeGLX matlab scripts  
addpath(genpath('C:\Users\labadmin\Documents\MATLAB\TONIC-master'))                 % TONIC-master folder
addpath(genpath('C:\Users\labadmin\Desktop\jrclust'));                              % jrclust folder

% on Mac use the following instead
% addpath('/Users/parkj/Documents/MATLAB')
% addpath('/Users/parkj/Desktop/SpikeGLX-master 2/MATLAB-SDK/')           % the folder with spikeGLX matlab scripts  
% addpath(genpath('/Users/parkj/Documents/MATLAB/TONIC-master/'))         % TONIC-master folder
% addpath(genpath('/Users/parkj/Desktop/jrclust_user'));                  % jrclust folder

%fileDirectory = 'E:\SGL_SSD_Data'; % must use the desktop hard drive for faster processing 
%saveDirectory = 'Z:\parkj\NeuralData\WR23_acc_dms_090117'; % processed file goes to the individual folder on RAID
fileDirectory = 'C:\Users\labadmin\Desktop\jrclust';
saveDirectory = 'Y:\Shared\Beth';
% fileDirectory = '/Volumes/RAID2/Shared/Beth';             % must use the desktop hard drive for faster processing 
% saveDirectory =  '/Volumes/RAID2/Shared/Beth';            % processed file goes to the individual folder on RAID %NOPE, won't let me

binName =  'Vgateight_17_04_27_g0_t0.nidq.bin';             % .bin filename (e.g. 'JP_WR16_2130um_dura_062117_g0_t0.nidq.bin')
cd(fileDirectory)

%saveDirectory    =  'Z:\parkj\NeuralData\WR20_Ldms_082317';                % saveDirectory for the .bin file
%cd(saveDirectory)    % change directory to the current data folder

% Parse the corresponding metafile
meta = ReadMeta(binName, fileDirectory);                 % get the meta data (structure)

% Read the binary data (entire samples)
nSamp         = SampRate(meta);                          % sampling rate (default: 25kHz) 
totalTimeSecs = str2double(meta.fileTimeSecs);           % total duration of file in seconds
etrSamples    = nSamp * totalTimeSecs;   % entire samples acquired during recording (sampling rate x recording duration in sec)

% To avoid memory issue read incrementally segment-by-segment in a loop
% dataArray12 = ReadBin(nSamp, nSamp, meta, binName, fileDirectory);  % time indexing is possible by setting the time offset; SampRate * time offset (s) - this will read binary data of 1 to 2 sec  

% Specify the relevant behavioral channel numbers
%NumbExtraProbe = 1; % Specify how many extra probes were used (e.g. zero if only one probe was used)
%XposCh = 64*NumbExtraProbe+97;  % channel # for X position (default channel numbers for 64 channel recording)
%YposCh = 64*NumbExtraProbe+101; % channel # for Y position
%lickCh = 64*NumbExtraProbe+69;  % channel # for lick port
%soleCh = 64*NumbExtraProbe+67;  % channel # for solenoid (water reward delivery) 

NumbExtraProbe = 0; % Specify how many extra probes were used (e.g. zero if only one probe was used)
trialStartCh = 195; XposCh = trialStartCh;
wheelCh = 195; YposCh = wheelCh;
lickCh = 225;
soleCh = 193

% preallocate the behavioral data arrays
Xpos    = zeros(1,floor(totalTimeSecs*1000)); % the time resolution will be 1000Hz after decimation
Ypos    = zeros(1,floor(totalTimeSecs*1000)); %
lick    = zeros(1,floor(totalTimeSecs*1000)); %
sole    = zeros(1,floor(totalTimeSecs*1000)); %

for i = 0:totalTimeSecs-1 % read second-by-second incrementally to avoid a memory issue
    tempDataArray = ReadBin(i*nSamp, nSamp, meta, binName, fileDirectory); % read bin data for each second
    tempXpos = decimate(tempDataArray(XposCh,:),nSamp/1000); % decimate the data
    tempYpos = decimate(tempDataArray(YposCh,:),nSamp/1000);
    templick = decimate(tempDataArray(lickCh,:),nSamp/1000);
    tempsole = decimate(tempDataArray(soleCh,:),nSamp/1000);
    Xpos(1,i*1000+1:(i+1)*1000) = tempXpos; % accumulated the decimated data
    Ypos(1,i*1000+1:(i+1)*1000) = tempYpos;
    lick(1,i*1000+1:(i+1)*1000) = templick;
    sole(1,i*1000+1:(i+1)*1000) = tempsole;
    clearvars temp*
    fprintf('processed %d\n', i+1) 
end
clearvars i

% Gain correction for channnels of interest
if strcmp(meta.typeThis, 'imec') % in case recording via imec 
    Xpos = GainCorrectIM(Xpos, 1, meta); % gain-corrected voltage trace for Xpos 
    Ypos = GainCorrectIM(Ypos, 1, meta); % gain-corrected voltage trace for Ypos 
    lick = GainCorrectIM(lick, 1, meta); % gain-corrected voltage trace for lick
    sole = GainCorrectIM(sole, 1, meta); % gain-corrected voltage trace for solenoid
else    % in case of recording via NI board
    Xpos = GainCorrectNI(Xpos, 1, meta); % gain-corrected voltage trace for Xpos 
    Ypos = GainCorrectNI(Ypos, 1, meta); % gain-corrected voltage trace for Ypos 
    lick = GainCorrectNI(lick, 1, meta); % gain-corrected voltage trace for lick 
    sole = GainCorrectNI(sole, 1, meta); % gain-corrected voltage trace for solenoid
end

% saveDirectory  = '/Volumes/RAID2/parkj/NeuralData/WR20_Ldms_082317';     % saveDirectory on my laptop
cd(saveDirectory)    % change directory to the current data folder
save('BehVariables', 'Xpos', 'Ypos', 'lick', 'sole');   % save relevant behavioral variables
% load('BehVariables', 'Xpos', 'Ypos', 'lick', 'sole'); % load relevant behavioral variables

%% Position/velocity data
positionData = [Xpos; Ypos];    % joystick position data

% Start working on this
% [ reachStart, reachStop, reach0, pos1, pos2 ] = getReachTimesJP( positionData );     % all reach traces, aligned to start (pos1), to stop (pos2)
[ reachStart, reachStop, reach0, pos1, pos2 ] = getReachTimes( positionData );     % all reach traces, aligned to start (pos1), to stop (pos2)

vel1 = diff(pos1, 1, 2); % reach velocity aligned to reach start (differentiation of pos1) 
vel2 = diff(pos2, 1, 2); % reach velocity aligned to reach stop (differentiation of pos2)
% plot(reach0) % reachMW is the amplitude readout of the whole session

%% Get other task events - licks, reward delivery
% reward delivery (solenoid activation)
rwdThres   = (max(sole) - median(sole))/2;      % not sure if this is the best way of setting the detection threshold;
rewInds    = find(sole>rwdThres);               % detect the solenoid TTL activation by threshold crossings
valRewInds = rewInds(diff([0, rewInds])>500);   % this ensures that there's no redundant detections of the same TTL pulse
plot(valRewInds,2e-5,'r*')

% lick detection
[~,~,licksem] = meanstdsem(abs(lick)');            % lick voltage traces comprise positive and negative deflections, both are meaningful - so take absolute values
lickThres     = mean(abs(lick))+3*licksem;         % this seems to work as a reasonable threshold for at least some animals, but not guaranteed to work universallly
lickInds      = find(lick>lickThres);              % find points of crossing the lick threshold
valLickInds   = lickInds(diff([0, lickInds])>100); % this ensures that there's no redundant detections of the same lick

lickTraces  = [];
%this part visualizes the detected lick traces for validation
 for i = 1:length(valLickInds)
     hold on;
     lickTraces(i,:) = lick(1,valLickInds(i)-100:valLickInds(i)+100);
     plot(valLickInds(i)-100:valLickInds(i)+100,lickTraces(i,:),'m')
     plot(valLickInds(i), lick(valLickInds(i)),'c*')
 end
clearvars i

% Build a structure for timestamps
ts.reachStart = reachStart;     % reachStart
ts.reachStop  = reachStop;      % reachStop
ts.reward     = valRewInds;     % reward deliveries
ts.lick       = valLickInds;    % licks

% Save relevant BehVariables
save('BehVariables', 'Xpos', 'Ypos', 'lickTraces', 'sole', 'reach0', 'pos1', 'pos2', 'vel1', 'vel2', 'ts') % append the position/velocity data variables
% load('BehVariables', 'Xpos', 'Ypos', 'lickTraces', 'sole', 'reach0', 'pos1', 'pos2', 'vel1', 'vel2', 'ts')


